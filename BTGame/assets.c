/***********************************************************************
   WARNING: This file generated by robots.  Do not attempt to modify.

   This API is for use with assets.db
   Which contains 7 table(s).
***********************************************************************/

#include "assets.h"
#include "DB.h"
#include "segashared/CheckedMemory.h"
#include "sqlite/sqlite3.h"

void dbImageDestroyStatements(DB_assets *db);
int dbImageCreateTable(DB_assets *db);
void dbPaletteDestroyStatements(DB_assets *db);
int dbPaletteCreateTable(DB_assets *db);
void dbSpriteDestroyStatements(DB_assets *db);
int dbSpriteCreateTable(DB_assets *db);
void dbSpriteFrameDestroyStatements(DB_assets *db);
int dbSpriteFrameCreateTable(DB_assets *db);
void dbTileSchemaDestroyStatements(DB_assets *db);
int dbTileSchemaCreateTable(DB_assets *db);
void dbLuaScriptDestroyStatements(DB_assets *db);
int dbLuaScriptCreateTable(DB_assets *db);
void dbMapDestroyStatements(DB_assets *db);
int dbMapCreateTable(DB_assets *db);

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBImageStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBPaletteStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBSpriteStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectBysprite;
   sqlite3_stmt *deleteBysprite;
} DBSpriteFrameStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByset;
   sqlite3_stmt *deleteByset;
} DBTileSchemaStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectBymodule;
   sqlite3_stmt *deleteBymodule;
} DBLuaScriptStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBMapStmts;

struct DB_assets{
   DBBase base;
   DBImageStmts ImageStmts;
   DBPaletteStmts PaletteStmts;
   DBSpriteStmts SpriteStmts;
   DBSpriteFrameStmts SpriteFrameStmts;
   DBTileSchemaStmts TileSchemaStmts;
   DBLuaScriptStmts LuaScriptStmts;
   DBMapStmts MapStmts;
};

DB_assets *db_assetsCreate(){
   DB_assets *out = checkedCalloc(1, sizeof(DB_assets));
   return out;
}

void db_assetsDestroy(DB_assets *self){
   dbDestroy((DBBase*)self);
   dbImageDestroyStatements(self);
   dbPaletteDestroyStatements(self);
   dbSpriteDestroyStatements(self);
   dbSpriteFrameDestroyStatements(self);
   dbTileSchemaDestroyStatements(self);
   dbLuaScriptDestroyStatements(self);
   dbMapDestroyStatements(self);
   checkedFree(self);
}

int db_assetsCreateTables(DB_assets *self){
   int result = 0;

   if((result = dbImageCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbPaletteCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbSpriteCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbSpriteFrameCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbTileSchemaCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbLuaScriptCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbMapCreateTable(self)) != DB_SUCCESS){ return result; }

   return DB_SUCCESS;
}

#define VectorTPart DBImage
#include "segautils/Vector_Impl.h"

void dbImageDestroy(DBImage *self){
   if(self->id){
      stringDestroy(self->id);
      self->id = NULL;
   }
   if(self->image){
      checkedFree(self->image);
      self->image = NULL;
   }
}
void dbImageDestroyStatements(DB_assets *db){
   if(db->ImageStmts.insert){
      sqlite3_finalize(db->ImageStmts.insert);
      db->ImageStmts.insert = NULL;
   }
   if(db->ImageStmts.update){
      sqlite3_finalize(db->ImageStmts.update);
      db->ImageStmts.update = NULL;
   }
   if(db->ImageStmts.selectAll){
      sqlite3_finalize(db->ImageStmts.selectAll);
      db->ImageStmts.selectAll = NULL;
   }
   if(db->ImageStmts.deleteAll){
      sqlite3_finalize(db->ImageStmts.deleteAll);
      db->ImageStmts.deleteAll = NULL;
   }
   if(db->ImageStmts.selectByid){
      sqlite3_finalize(db->ImageStmts.selectByid);
      db->ImageStmts.selectByid = NULL;
   }
   if(db->ImageStmts.deleteByid){
      sqlite3_finalize(db->ImageStmts.deleteByid);
      db->ImageStmts.deleteByid = NULL;
   }
}
int dbImageCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"Image\" (\"id\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"image\" BLOB);";
   return dbExecute((DBBase*)db, cmd);
}
int dbImageInsert(DB_assets *db, const DBImage *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Image\" (\"id\", \"image\") VALUES (:id, :image);";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->ImageStmts.insert, 1, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->ImageStmts.insert, 2, obj->image, obj->imageSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->ImageStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbImageUpdate(DB_assets *db, const DBImage *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Image\" SET (\"image\" = :image) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_blob(db->ImageStmts.update, 1, obj->image, obj->imageSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->ImageStmts.update, 2, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->ImageStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBImage) *dbImageSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Image\";";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBImage) *out = vecCreate(DBImage)(&dbImageDestroy);

   while((result = sqlite3_step(db->ImageStmts.selectAll)) == SQLITE_ROW){
      DBImage newObj = {0};

      newObj.id = stringCreate(sqlite3_column_text(db->ImageStmts.selectAll, 0));
      newObj.imageSize = sqlite3_column_bytes(db->ImageStmts.selectAll, 1);
      newObj.image = checkedCalloc(1, newObj.imageSize);
      memcpy(newObj.image, sqlite3_column_blob(db->ImageStmts.selectAll, 1), newObj.imageSize);
      
      vecPushBack(DBImage)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBImage)(out);
      return NULL;
   }

   return out;
}
DBImage dbImageSelectFirstByid(DB_assets *db, const char *id){
   DBImage out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Image\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->ImageStmts.selectByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->ImageStmts.selectByid)) == SQLITE_ROW){
      out.id = stringCreate(sqlite3_column_text(db->ImageStmts.selectByid, 0));
      out.imageSize = sqlite3_column_bytes(db->ImageStmts.selectByid, 1);
      out.image = checkedCalloc(1, out.imageSize);
      memcpy(out.image, sqlite3_column_blob(db->ImageStmts.selectByid, 1), out.imageSize);
   };

   return out;
}
int dbImageDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbImageDeleteByid(DB_assets *db, const char *id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"Image\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->ImageStmts.deleteByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->ImageStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBPalette
#include "segautils/Vector_Impl.h"

void dbPaletteDestroy(DBPalette *self){
   if(self->id){
      stringDestroy(self->id);
      self->id = NULL;
   }
   if(self->palette){
      checkedFree(self->palette);
      self->palette = NULL;
   }
}
void dbPaletteDestroyStatements(DB_assets *db){
   if(db->PaletteStmts.insert){
      sqlite3_finalize(db->PaletteStmts.insert);
      db->PaletteStmts.insert = NULL;
   }
   if(db->PaletteStmts.update){
      sqlite3_finalize(db->PaletteStmts.update);
      db->PaletteStmts.update = NULL;
   }
   if(db->PaletteStmts.selectAll){
      sqlite3_finalize(db->PaletteStmts.selectAll);
      db->PaletteStmts.selectAll = NULL;
   }
   if(db->PaletteStmts.deleteAll){
      sqlite3_finalize(db->PaletteStmts.deleteAll);
      db->PaletteStmts.deleteAll = NULL;
   }
   if(db->PaletteStmts.selectByid){
      sqlite3_finalize(db->PaletteStmts.selectByid);
      db->PaletteStmts.selectByid = NULL;
   }
   if(db->PaletteStmts.deleteByid){
      sqlite3_finalize(db->PaletteStmts.deleteByid);
      db->PaletteStmts.deleteByid = NULL;
   }
}
int dbPaletteCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"Palette\" (\"id\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"palette\" BLOB);";
   return dbExecute((DBBase*)db, cmd);
}
int dbPaletteInsert(DB_assets *db, const DBPalette *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Palette\" (\"id\", \"palette\") VALUES (:id, :palette);";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->PaletteStmts.insert, 1, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->PaletteStmts.insert, 2, obj->palette, obj->paletteSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbPaletteUpdate(DB_assets *db, const DBPalette *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Palette\" SET (\"palette\" = :palette) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_blob(db->PaletteStmts.update, 1, obj->palette, obj->paletteSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->PaletteStmts.update, 2, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBPalette) *dbPaletteSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Palette\";";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBPalette) *out = vecCreate(DBPalette)(&dbPaletteDestroy);

   while((result = sqlite3_step(db->PaletteStmts.selectAll)) == SQLITE_ROW){
      DBPalette newObj = {0};

      newObj.id = stringCreate(sqlite3_column_text(db->PaletteStmts.selectAll, 0));
      newObj.paletteSize = sqlite3_column_bytes(db->PaletteStmts.selectAll, 1);
      newObj.palette = checkedCalloc(1, newObj.paletteSize);
      memcpy(newObj.palette, sqlite3_column_blob(db->PaletteStmts.selectAll, 1), newObj.paletteSize);
      
      vecPushBack(DBPalette)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBPalette)(out);
      return NULL;
   }

   return out;
}
DBPalette dbPaletteSelectFirstByid(DB_assets *db, const char *id){
   DBPalette out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Palette\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->PaletteStmts.selectByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->PaletteStmts.selectByid)) == SQLITE_ROW){
      out.id = stringCreate(sqlite3_column_text(db->PaletteStmts.selectByid, 0));
      out.paletteSize = sqlite3_column_bytes(db->PaletteStmts.selectByid, 1);
      out.palette = checkedCalloc(1, out.paletteSize);
      memcpy(out.palette, sqlite3_column_blob(db->PaletteStmts.selectByid, 1), out.paletteSize);
   };

   return out;
}
int dbPaletteDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbPaletteDeleteByid(DB_assets *db, const char *id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"Palette\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->PaletteStmts.deleteByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBSprite
#include "segautils/Vector_Impl.h"

void dbSpriteDestroy(DBSprite *self){
   if(self->id){
      stringDestroy(self->id);
      self->id = NULL;
   }
}
void dbSpriteDestroyStatements(DB_assets *db){
   if(db->SpriteStmts.insert){
      sqlite3_finalize(db->SpriteStmts.insert);
      db->SpriteStmts.insert = NULL;
   }
   if(db->SpriteStmts.update){
      sqlite3_finalize(db->SpriteStmts.update);
      db->SpriteStmts.update = NULL;
   }
   if(db->SpriteStmts.selectAll){
      sqlite3_finalize(db->SpriteStmts.selectAll);
      db->SpriteStmts.selectAll = NULL;
   }
   if(db->SpriteStmts.deleteAll){
      sqlite3_finalize(db->SpriteStmts.deleteAll);
      db->SpriteStmts.deleteAll = NULL;
   }
   if(db->SpriteStmts.selectByid){
      sqlite3_finalize(db->SpriteStmts.selectByid);
      db->SpriteStmts.selectByid = NULL;
   }
   if(db->SpriteStmts.deleteByid){
      sqlite3_finalize(db->SpriteStmts.deleteByid);
      db->SpriteStmts.deleteByid = NULL;
   }
}
int dbSpriteCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"Sprite\" (\"id\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"width\" INTEGER, \"height\" INTEGER);";
   return dbExecute((DBBase*)db, cmd);
}
int dbSpriteInsert(DB_assets *db, const DBSprite *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Sprite\" (\"id\", \"width\", \"height\") VALUES (:id, :width, :height);";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->SpriteStmts.insert, 1, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteStmts.insert, 2, (int)obj->width);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteStmts.insert, 3, (int)obj->height);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->SpriteStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbSpriteUpdate(DB_assets *db, const DBSprite *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Sprite\" SET (\"width\" = :width, \"height\" = :height) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->SpriteStmts.update, 1, (int)obj->width);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteStmts.update, 2, (int)obj->height);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->SpriteStmts.update, 3, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->SpriteStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBSprite) *dbSpriteSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Sprite\";";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBSprite) *out = vecCreate(DBSprite)(&dbSpriteDestroy);

   while((result = sqlite3_step(db->SpriteStmts.selectAll)) == SQLITE_ROW){
      DBSprite newObj = {0};

      newObj.id = stringCreate(sqlite3_column_text(db->SpriteStmts.selectAll, 0));
      newObj.width = sqlite3_column_int(db->SpriteStmts.selectAll, 1);
      newObj.height = sqlite3_column_int(db->SpriteStmts.selectAll, 2);
      
      vecPushBack(DBSprite)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBSprite)(out);
      return NULL;
   }

   return out;
}
DBSprite dbSpriteSelectFirstByid(DB_assets *db, const char *id){
   DBSprite out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Sprite\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->SpriteStmts.selectByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->SpriteStmts.selectByid)) == SQLITE_ROW){
      out.id = stringCreate(sqlite3_column_text(db->SpriteStmts.selectByid, 0));
      out.width = sqlite3_column_int(db->SpriteStmts.selectByid, 1);
      out.height = sqlite3_column_int(db->SpriteStmts.selectByid, 2);
   };

   return out;
}
int dbSpriteDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbSpriteDeleteByid(DB_assets *db, const char *id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"Sprite\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->SpriteStmts.deleteByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->SpriteStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBSpriteFrame
#include "segautils/Vector_Impl.h"

void dbSpriteFrameDestroy(DBSpriteFrame *self){
   if(self->sprite){
      stringDestroy(self->sprite);
      self->sprite = NULL;
   }
   if(self->image){
      stringDestroy(self->image);
      self->image = NULL;
   }
}
void dbSpriteFrameDestroyStatements(DB_assets *db){
   if(db->SpriteFrameStmts.insert){
      sqlite3_finalize(db->SpriteFrameStmts.insert);
      db->SpriteFrameStmts.insert = NULL;
   }
   if(db->SpriteFrameStmts.update){
      sqlite3_finalize(db->SpriteFrameStmts.update);
      db->SpriteFrameStmts.update = NULL;
   }
   if(db->SpriteFrameStmts.selectAll){
      sqlite3_finalize(db->SpriteFrameStmts.selectAll);
      db->SpriteFrameStmts.selectAll = NULL;
   }
   if(db->SpriteFrameStmts.deleteAll){
      sqlite3_finalize(db->SpriteFrameStmts.deleteAll);
      db->SpriteFrameStmts.deleteAll = NULL;
   }
   if(db->SpriteFrameStmts.selectBysprite){
      sqlite3_finalize(db->SpriteFrameStmts.selectBysprite);
      db->SpriteFrameStmts.selectBysprite = NULL;
   }
   if(db->SpriteFrameStmts.deleteBysprite){
      sqlite3_finalize(db->SpriteFrameStmts.deleteBysprite);
      db->SpriteFrameStmts.deleteBysprite = NULL;
   }
}
int dbSpriteFrameCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"SpriteFrame\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"sprite\" STRING, \"image\" STRING, \"index\" INTEGER, \"imgX\" INTEGER, \"imgY\" INTEGER);";
   return dbExecute((DBBase*)db, cmd);
}
int dbSpriteFrameInsert(DB_assets *db, const DBSpriteFrame *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"SpriteFrame\" (\"sprite\", \"image\", \"index\", \"imgX\", \"imgY\") VALUES (:sprite, :image, :index, :imgX, :imgY);";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteFrameStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->SpriteFrameStmts.insert, 1, c_str(obj->sprite), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->SpriteFrameStmts.insert, 2, c_str(obj->image), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteFrameStmts.insert, 3, (int)obj->index);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteFrameStmts.insert, 4, (int)obj->imgX);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteFrameStmts.insert, 5, (int)obj->imgY);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->SpriteFrameStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbSpriteFrameUpdate(DB_assets *db, const DBSpriteFrame *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"SpriteFrame\" SET (\"sprite\" = :sprite, \"image\" = :image, \"index\" = :index, \"imgX\" = :imgX, \"imgY\" = :imgY) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteFrameStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->SpriteFrameStmts.update, 1, c_str(obj->sprite), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->SpriteFrameStmts.update, 2, c_str(obj->image), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteFrameStmts.update, 3, (int)obj->index);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteFrameStmts.update, 4, (int)obj->imgX);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->SpriteFrameStmts.update, 5, (int)obj->imgY);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->SpriteFrameStmts.update, 6, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->SpriteFrameStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBSpriteFrame) *dbSpriteFrameSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"SpriteFrame\";";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteFrameStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBSpriteFrame) *out = vecCreate(DBSpriteFrame)(&dbSpriteFrameDestroy);

   while((result = sqlite3_step(db->SpriteFrameStmts.selectAll)) == SQLITE_ROW){
      DBSpriteFrame newObj = {0};

      newObj.id = sqlite3_column_int(db->SpriteFrameStmts.selectAll, 0);
      newObj.sprite = stringCreate(sqlite3_column_text(db->SpriteFrameStmts.selectAll, 1));
      newObj.image = stringCreate(sqlite3_column_text(db->SpriteFrameStmts.selectAll, 2));
      newObj.index = sqlite3_column_int(db->SpriteFrameStmts.selectAll, 3);
      newObj.imgX = sqlite3_column_int(db->SpriteFrameStmts.selectAll, 4);
      newObj.imgY = sqlite3_column_int(db->SpriteFrameStmts.selectAll, 5);
      
      vecPushBack(DBSpriteFrame)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBSpriteFrame)(out);
      return NULL;
   }

   return out;
}
DBSpriteFrame dbSpriteFrameSelectFirstBysprite(DB_assets *db, const char *sprite){
   DBSpriteFrame out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"SpriteFrame\" WHERE \"sprite\" = :sprite;";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteFrameStmts.selectBysprite, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->SpriteFrameStmts.selectBysprite, 1, sprite, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->SpriteFrameStmts.selectBysprite)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 0);
      out.sprite = stringCreate(sqlite3_column_text(db->SpriteFrameStmts.selectBysprite, 1));
      out.image = stringCreate(sqlite3_column_text(db->SpriteFrameStmts.selectBysprite, 2));
      out.index = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 3);
      out.imgX = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 4);
      out.imgY = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 5);
   };

   return out;
}
vec(DBSpriteFrame) *dbSpriteFrameSelectBysprite(DB_assets *db, const char *sprite){
   int result = 0;
   vec(DBSpriteFrame) *out = NULL;
   static const char *stmt = "SELECT * FROM \"SpriteFrame\" WHERE \"sprite\" = :sprite;";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteFrameStmts.selectBysprite, stmt) != DB_SUCCESS){
      return NULL;
   }

   result = sqlite3_bind_text(db->SpriteFrameStmts.selectBysprite, 1, sprite, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   out = vecCreate(DBSpriteFrame)(&dbSpriteFrameDestroy);

   while((result = sqlite3_step(db->SpriteFrameStmts.selectBysprite)) == SQLITE_ROW){
      DBSpriteFrame newObj = {0};

      newObj.id = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 0);
      newObj.sprite = stringCreate(sqlite3_column_text(db->SpriteFrameStmts.selectBysprite, 1));
      newObj.image = stringCreate(sqlite3_column_text(db->SpriteFrameStmts.selectBysprite, 2));
      newObj.index = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 3);
      newObj.imgX = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 4);
      newObj.imgY = sqlite3_column_int(db->SpriteFrameStmts.selectBysprite, 5);
      
      vecPushBack(DBSpriteFrame)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBSpriteFrame)(out);
      return NULL;
   }

   return out;
}
int dbSpriteFrameDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbSpriteFrameDeleteBysprite(DB_assets *db, const char *sprite){
   int result = 0;
   static const char *stmt = "DELETE FROM \"SpriteFrame\" WHERE (\"sprite\" = :sprite);";
   if(dbPrepareStatement((DBBase*)db, &db->SpriteFrameStmts.deleteBysprite, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->SpriteFrameStmts.deleteBysprite, 1, sprite, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->SpriteFrameStmts.deleteBysprite);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBTileSchema
#include "segautils/Vector_Impl.h"

void dbTileSchemaDestroy(DBTileSchema *self){
   if(self->set){
      stringDestroy(self->set);
      self->set = NULL;
   }
   if(self->sprite){
      stringDestroy(self->sprite);
      self->sprite = NULL;
   }
}
void dbTileSchemaDestroyStatements(DB_assets *db){
   if(db->TileSchemaStmts.insert){
      sqlite3_finalize(db->TileSchemaStmts.insert);
      db->TileSchemaStmts.insert = NULL;
   }
   if(db->TileSchemaStmts.update){
      sqlite3_finalize(db->TileSchemaStmts.update);
      db->TileSchemaStmts.update = NULL;
   }
   if(db->TileSchemaStmts.selectAll){
      sqlite3_finalize(db->TileSchemaStmts.selectAll);
      db->TileSchemaStmts.selectAll = NULL;
   }
   if(db->TileSchemaStmts.deleteAll){
      sqlite3_finalize(db->TileSchemaStmts.deleteAll);
      db->TileSchemaStmts.deleteAll = NULL;
   }
   if(db->TileSchemaStmts.selectByset){
      sqlite3_finalize(db->TileSchemaStmts.selectByset);
      db->TileSchemaStmts.selectByset = NULL;
   }
   if(db->TileSchemaStmts.deleteByset){
      sqlite3_finalize(db->TileSchemaStmts.deleteByset);
      db->TileSchemaStmts.deleteByset = NULL;
   }
}
int dbTileSchemaCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"TileSchema\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"set\" STRING, \"sprite\" STRING, \"lit\" BOOLEAN, \"radius\" INTEGER, \"centerLevel\" INTEGER, \"fadeWidth\" INTEGER, \"occlusion\" BOOLEAN);";
   return dbExecute((DBBase*)db, cmd);
}
int dbTileSchemaInsert(DB_assets *db, const DBTileSchema *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"TileSchema\" (\"set\", \"sprite\", \"lit\", \"radius\", \"centerLevel\", \"fadeWidth\", \"occlusion\") VALUES (:set, :sprite, :lit, :radius, :centerLevel, :fadeWidth, :occlusion);";
   if(dbPrepareStatement((DBBase*)db, &db->TileSchemaStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->TileSchemaStmts.insert, 1, c_str(obj->set), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->TileSchemaStmts.insert, 2, c_str(obj->sprite), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.insert, 3, (int)obj->lit);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.insert, 4, (int)obj->radius);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.insert, 5, (int)obj->centerLevel);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.insert, 6, (int)obj->fadeWidth);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.insert, 7, (int)obj->occlusion);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->TileSchemaStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbTileSchemaUpdate(DB_assets *db, const DBTileSchema *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"TileSchema\" SET (\"set\" = :set, \"sprite\" = :sprite, \"lit\" = :lit, \"radius\" = :radius, \"centerLevel\" = :centerLevel, \"fadeWidth\" = :fadeWidth, \"occlusion\" = :occlusion) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->TileSchemaStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->TileSchemaStmts.update, 1, c_str(obj->set), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->TileSchemaStmts.update, 2, c_str(obj->sprite), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.update, 3, (int)obj->lit);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.update, 4, (int)obj->radius);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.update, 5, (int)obj->centerLevel);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.update, 6, (int)obj->fadeWidth);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->TileSchemaStmts.update, 7, (int)obj->occlusion);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->TileSchemaStmts.update, 8, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->TileSchemaStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBTileSchema) *dbTileSchemaSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"TileSchema\";";
   if(dbPrepareStatement((DBBase*)db, &db->TileSchemaStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBTileSchema) *out = vecCreate(DBTileSchema)(&dbTileSchemaDestroy);

   while((result = sqlite3_step(db->TileSchemaStmts.selectAll)) == SQLITE_ROW){
      DBTileSchema newObj = {0};

      newObj.id = sqlite3_column_int(db->TileSchemaStmts.selectAll, 0);
      newObj.set = stringCreate(sqlite3_column_text(db->TileSchemaStmts.selectAll, 1));
      newObj.sprite = stringCreate(sqlite3_column_text(db->TileSchemaStmts.selectAll, 2));
      newObj.lit = sqlite3_column_int(db->TileSchemaStmts.selectAll, 3);
      newObj.radius = sqlite3_column_int(db->TileSchemaStmts.selectAll, 4);
      newObj.centerLevel = sqlite3_column_int(db->TileSchemaStmts.selectAll, 5);
      newObj.fadeWidth = sqlite3_column_int(db->TileSchemaStmts.selectAll, 6);
      newObj.occlusion = sqlite3_column_int(db->TileSchemaStmts.selectAll, 7);
      
      vecPushBack(DBTileSchema)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBTileSchema)(out);
      return NULL;
   }

   return out;
}
DBTileSchema dbTileSchemaSelectFirstByset(DB_assets *db, const char *set){
   DBTileSchema out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"TileSchema\" WHERE \"set\" = :set;";
   if(dbPrepareStatement((DBBase*)db, &db->TileSchemaStmts.selectByset, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->TileSchemaStmts.selectByset, 1, set, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->TileSchemaStmts.selectByset)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->TileSchemaStmts.selectByset, 0);
      out.set = stringCreate(sqlite3_column_text(db->TileSchemaStmts.selectByset, 1));
      out.sprite = stringCreate(sqlite3_column_text(db->TileSchemaStmts.selectByset, 2));
      out.lit = sqlite3_column_int(db->TileSchemaStmts.selectByset, 3);
      out.radius = sqlite3_column_int(db->TileSchemaStmts.selectByset, 4);
      out.centerLevel = sqlite3_column_int(db->TileSchemaStmts.selectByset, 5);
      out.fadeWidth = sqlite3_column_int(db->TileSchemaStmts.selectByset, 6);
      out.occlusion = sqlite3_column_int(db->TileSchemaStmts.selectByset, 7);
   };

   return out;
}
vec(DBTileSchema) *dbTileSchemaSelectByset(DB_assets *db, const char *set){
   int result = 0;
   vec(DBTileSchema) *out = NULL;
   static const char *stmt = "SELECT * FROM \"TileSchema\" WHERE \"set\" = :set;";
   if(dbPrepareStatement((DBBase*)db, &db->TileSchemaStmts.selectByset, stmt) != DB_SUCCESS){
      return NULL;
   }

   result = sqlite3_bind_text(db->TileSchemaStmts.selectByset, 1, set, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   out = vecCreate(DBTileSchema)(&dbTileSchemaDestroy);

   while((result = sqlite3_step(db->TileSchemaStmts.selectByset)) == SQLITE_ROW){
      DBTileSchema newObj = {0};

      newObj.id = sqlite3_column_int(db->TileSchemaStmts.selectByset, 0);
      newObj.set = stringCreate(sqlite3_column_text(db->TileSchemaStmts.selectByset, 1));
      newObj.sprite = stringCreate(sqlite3_column_text(db->TileSchemaStmts.selectByset, 2));
      newObj.lit = sqlite3_column_int(db->TileSchemaStmts.selectByset, 3);
      newObj.radius = sqlite3_column_int(db->TileSchemaStmts.selectByset, 4);
      newObj.centerLevel = sqlite3_column_int(db->TileSchemaStmts.selectByset, 5);
      newObj.fadeWidth = sqlite3_column_int(db->TileSchemaStmts.selectByset, 6);
      newObj.occlusion = sqlite3_column_int(db->TileSchemaStmts.selectByset, 7);
      
      vecPushBack(DBTileSchema)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBTileSchema)(out);
      return NULL;
   }

   return out;
}
int dbTileSchemaDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbTileSchemaDeleteByset(DB_assets *db, const char *set){
   int result = 0;
   static const char *stmt = "DELETE FROM \"TileSchema\" WHERE (\"set\" = :set);";
   if(dbPrepareStatement((DBBase*)db, &db->TileSchemaStmts.deleteByset, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->TileSchemaStmts.deleteByset, 1, set, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->TileSchemaStmts.deleteByset);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBLuaScript
#include "segautils/Vector_Impl.h"

void dbLuaScriptDestroy(DBLuaScript *self){
   if(self->module){
      stringDestroy(self->module);
      self->module = NULL;
   }
   if(self->script){
      stringDestroy(self->script);
      self->script = NULL;
   }
}
void dbLuaScriptDestroyStatements(DB_assets *db){
   if(db->LuaScriptStmts.insert){
      sqlite3_finalize(db->LuaScriptStmts.insert);
      db->LuaScriptStmts.insert = NULL;
   }
   if(db->LuaScriptStmts.update){
      sqlite3_finalize(db->LuaScriptStmts.update);
      db->LuaScriptStmts.update = NULL;
   }
   if(db->LuaScriptStmts.selectAll){
      sqlite3_finalize(db->LuaScriptStmts.selectAll);
      db->LuaScriptStmts.selectAll = NULL;
   }
   if(db->LuaScriptStmts.deleteAll){
      sqlite3_finalize(db->LuaScriptStmts.deleteAll);
      db->LuaScriptStmts.deleteAll = NULL;
   }
   if(db->LuaScriptStmts.selectBymodule){
      sqlite3_finalize(db->LuaScriptStmts.selectBymodule);
      db->LuaScriptStmts.selectBymodule = NULL;
   }
   if(db->LuaScriptStmts.deleteBymodule){
      sqlite3_finalize(db->LuaScriptStmts.deleteBymodule);
      db->LuaScriptStmts.deleteBymodule = NULL;
   }
}
int dbLuaScriptCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"LuaScript\" (\"module\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"script\" STRING);";
   return dbExecute((DBBase*)db, cmd);
}
int dbLuaScriptInsert(DB_assets *db, const DBLuaScript *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"LuaScript\" (\"module\", \"script\") VALUES (:module, :script);";
   if(dbPrepareStatement((DBBase*)db, &db->LuaScriptStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->LuaScriptStmts.insert, 1, c_str(obj->module), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->LuaScriptStmts.insert, 2, c_str(obj->script), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->LuaScriptStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbLuaScriptUpdate(DB_assets *db, const DBLuaScript *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"LuaScript\" SET (\"script\" = :script) WHERE (\"module\" = :module)";
   if(dbPrepareStatement((DBBase*)db, &db->LuaScriptStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->LuaScriptStmts.update, 1, c_str(obj->script), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->LuaScriptStmts.update, 2, c_str(obj->module), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->LuaScriptStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBLuaScript) *dbLuaScriptSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"LuaScript\";";
   if(dbPrepareStatement((DBBase*)db, &db->LuaScriptStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBLuaScript) *out = vecCreate(DBLuaScript)(&dbLuaScriptDestroy);

   while((result = sqlite3_step(db->LuaScriptStmts.selectAll)) == SQLITE_ROW){
      DBLuaScript newObj = {0};

      newObj.module = stringCreate(sqlite3_column_text(db->LuaScriptStmts.selectAll, 0));
      newObj.script = stringCreate(sqlite3_column_text(db->LuaScriptStmts.selectAll, 1));
      
      vecPushBack(DBLuaScript)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBLuaScript)(out);
      return NULL;
   }

   return out;
}
DBLuaScript dbLuaScriptSelectFirstBymodule(DB_assets *db, const char *module){
   DBLuaScript out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"LuaScript\" WHERE \"module\" = :module;";
   if(dbPrepareStatement((DBBase*)db, &db->LuaScriptStmts.selectBymodule, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->LuaScriptStmts.selectBymodule, 1, module, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->LuaScriptStmts.selectBymodule)) == SQLITE_ROW){
      out.module = stringCreate(sqlite3_column_text(db->LuaScriptStmts.selectBymodule, 0));
      out.script = stringCreate(sqlite3_column_text(db->LuaScriptStmts.selectBymodule, 1));
   };

   return out;
}
int dbLuaScriptDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbLuaScriptDeleteBymodule(DB_assets *db, const char *module){
   int result = 0;
   static const char *stmt = "DELETE FROM \"LuaScript\" WHERE (\"module\" = :module);";
   if(dbPrepareStatement((DBBase*)db, &db->LuaScriptStmts.deleteBymodule, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->LuaScriptStmts.deleteBymodule, 1, module, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->LuaScriptStmts.deleteBymodule);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBMap
#include "segautils/Vector_Impl.h"

void dbMapDestroy(DBMap *self){
   if(self->id){
      stringDestroy(self->id);
      self->id = NULL;
   }
   if(self->map){
      checkedFree(self->map);
      self->map = NULL;
   }
}
void dbMapDestroyStatements(DB_assets *db){
   if(db->MapStmts.insert){
      sqlite3_finalize(db->MapStmts.insert);
      db->MapStmts.insert = NULL;
   }
   if(db->MapStmts.update){
      sqlite3_finalize(db->MapStmts.update);
      db->MapStmts.update = NULL;
   }
   if(db->MapStmts.selectAll){
      sqlite3_finalize(db->MapStmts.selectAll);
      db->MapStmts.selectAll = NULL;
   }
   if(db->MapStmts.deleteAll){
      sqlite3_finalize(db->MapStmts.deleteAll);
      db->MapStmts.deleteAll = NULL;
   }
   if(db->MapStmts.selectByid){
      sqlite3_finalize(db->MapStmts.selectByid);
      db->MapStmts.selectByid = NULL;
   }
   if(db->MapStmts.deleteByid){
      sqlite3_finalize(db->MapStmts.deleteByid);
      db->MapStmts.deleteByid = NULL;
   }
}
int dbMapCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"Map\" (\"id\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"map\" BLOB);";
   return dbExecute((DBBase*)db, cmd);
}
int dbMapInsert(DB_assets *db, const DBMap *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Map\" (\"id\", \"map\") VALUES (:id, :map);";
   if(dbPrepareStatement((DBBase*)db, &db->MapStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->MapStmts.insert, 1, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->MapStmts.insert, 2, obj->map, obj->mapSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->MapStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbMapUpdate(DB_assets *db, const DBMap *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Map\" SET (\"map\" = :map) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->MapStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_blob(db->MapStmts.update, 1, obj->map, obj->mapSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->MapStmts.update, 2, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->MapStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBMap) *dbMapSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Map\";";
   if(dbPrepareStatement((DBBase*)db, &db->MapStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBMap) *out = vecCreate(DBMap)(&dbMapDestroy);

   while((result = sqlite3_step(db->MapStmts.selectAll)) == SQLITE_ROW){
      DBMap newObj = {0};

      newObj.id = stringCreate(sqlite3_column_text(db->MapStmts.selectAll, 0));
      newObj.mapSize = sqlite3_column_bytes(db->MapStmts.selectAll, 1);
      newObj.map = checkedCalloc(1, newObj.mapSize);
      memcpy(newObj.map, sqlite3_column_blob(db->MapStmts.selectAll, 1), newObj.mapSize);
      
      vecPushBack(DBMap)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBMap)(out);
      return NULL;
   }

   return out;
}
DBMap dbMapSelectFirstByid(DB_assets *db, const char *id){
   DBMap out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Map\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->MapStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->MapStmts.selectByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->MapStmts.selectByid)) == SQLITE_ROW){
      out.id = stringCreate(sqlite3_column_text(db->MapStmts.selectByid, 0));
      out.mapSize = sqlite3_column_bytes(db->MapStmts.selectByid, 1);
      out.map = checkedCalloc(1, out.mapSize);
      memcpy(out.map, sqlite3_column_blob(db->MapStmts.selectByid, 1), out.mapSize);
   };

   return out;
}
int dbMapDeleteAll(DB_assets *db){
return DB_SUCCESS;
}
int dbMapDeleteByid(DB_assets *db, const char *id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"Map\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->MapStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->MapStmts.deleteByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->MapStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
