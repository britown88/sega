/***********************************************************************
   WARNING: This file generated by robots.  Do not attempt to modify.

   This API is for use with assets.db
   Which contains 2 table(s).
***********************************************************************/

#include "assets.h"
#include "DB.h"
#include "segashared/CheckedMemory.h"
#include "sqlite/sqlite3.h"

void dbImageDestroyStatements(DB_assets *db);
int dbImageCreateTable(DB_assets *db);
void dbPaletteDestroyStatements(DB_assets *db);
int dbPaletteCreateTable(DB_assets *db);

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBImageStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBPaletteStmts;

struct DB_assets{
   DBBase base;
   DBImageStmts ImageStmts;
   DBPaletteStmts PaletteStmts;
};

DB_assets *db_assetsCreate(){
   DB_assets *out = checkedCalloc(1, sizeof(DB_assets));
   return out;
}

void db_assetsDestroy(DB_assets *self){
   dbDestroy((DBBase*)self);
   dbImageDestroyStatements(self);
   dbPaletteDestroyStatements(self);
   checkedFree(self);
}

int db_assetsCreateTables(DB_assets *self){
   int result = 0;

   if((result = dbImageCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbPaletteCreateTable(self)) != DB_SUCCESS){ return result; }

   return DB_SUCCESS;
}

#define VectorTPart DBImage
#include "segautils/Vector_Impl.h"

void dbImageDestroy(DBImage *self){
   if(self->id){
      stringDestroy(self->id);
      self->id = NULL;
   }
   if(self->image){
      checkedFree(self->image);
      self->image = NULL;
   }
}
void dbImageDestroyStatements(DB_assets *db){
   if(db->ImageStmts.insert){
      sqlite3_finalize(db->ImageStmts.insert);
      db->ImageStmts.insert = NULL;
   }
   if(db->ImageStmts.update){
      sqlite3_finalize(db->ImageStmts.update);
      db->ImageStmts.update = NULL;
   }
   if(db->ImageStmts.selectAll){
      sqlite3_finalize(db->ImageStmts.selectAll);
      db->ImageStmts.selectAll = NULL;
   }
   if(db->ImageStmts.deleteAll){
      sqlite3_finalize(db->ImageStmts.deleteAll);
      db->ImageStmts.deleteAll = NULL;
   }
   if(db->ImageStmts.selectByid){
      sqlite3_finalize(db->ImageStmts.selectByid);
      db->ImageStmts.selectByid = NULL;
   }
   if(db->ImageStmts.deleteByid){
      sqlite3_finalize(db->ImageStmts.deleteByid);
      db->ImageStmts.deleteByid = NULL;
   }
}
int dbImageCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"Image\" (\"id\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"image\" BLOB);";
   return dbExecute((DBBase*)db, cmd);
}
int dbImageInsert(DB_assets *db, const DBImage *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Image\" (\"id\", \"image\") VALUES (:id, :image);";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->ImageStmts.insert, 1, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->ImageStmts.insert, 2, obj->image, obj->imageSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->ImageStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbImageUpdate(DB_assets *db, const DBImage *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Image\" SET (\"image\" = :image) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_blob(db->ImageStmts.update, 1, obj->image, obj->imageSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->ImageStmts.update, 2, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->ImageStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBImage) *dbImageSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Image\";";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBImage) *out = vecCreate(DBImage)(&dbImageDestroy);

   while((result = sqlite3_step(db->ImageStmts.selectAll)) == SQLITE_ROW){
      DBImage newObj = {0};

      newObj.id = stringCreate(sqlite3_column_text(db->ImageStmts.selectAll, 0));
      newObj.imageSize = sqlite3_column_bytes(db->ImageStmts.selectAll, 1);
      newObj.image = checkedCalloc(1, newObj.imageSize);
      memcpy(newObj.image, sqlite3_column_blob(db->ImageStmts.selectAll, 1), newObj.imageSize);
      
      vecPushBack(DBImage)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBImage)(out);
      return NULL;
   }

   return out;
}
DBImage dbImageSelectFirstByid(DB_assets *db, const char *id){
   DBImage out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Image\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->ImageStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->ImageStmts.selectByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->ImageStmts.selectByid)) == SQLITE_ROW){
      out.id = stringCreate(sqlite3_column_text(db->ImageStmts.selectByid, 0));
      out.imageSize = sqlite3_column_bytes(db->ImageStmts.selectByid, 1);
      out.image = checkedCalloc(1, out.imageSize);
      memcpy(out.image, sqlite3_column_blob(db->ImageStmts.selectByid, 1), out.imageSize);
   };

   return out;
}
void dbImageDeleteAll(DB_assets *db){

}
void dbImageDeleteByid(DB_assets *db, const char *id){

}
#define VectorTPart DBPalette
#include "segautils/Vector_Impl.h"

void dbPaletteDestroy(DBPalette *self){
   if(self->id){
      stringDestroy(self->id);
      self->id = NULL;
   }
   if(self->palette){
      checkedFree(self->palette);
      self->palette = NULL;
   }
}
void dbPaletteDestroyStatements(DB_assets *db){
   if(db->PaletteStmts.insert){
      sqlite3_finalize(db->PaletteStmts.insert);
      db->PaletteStmts.insert = NULL;
   }
   if(db->PaletteStmts.update){
      sqlite3_finalize(db->PaletteStmts.update);
      db->PaletteStmts.update = NULL;
   }
   if(db->PaletteStmts.selectAll){
      sqlite3_finalize(db->PaletteStmts.selectAll);
      db->PaletteStmts.selectAll = NULL;
   }
   if(db->PaletteStmts.deleteAll){
      sqlite3_finalize(db->PaletteStmts.deleteAll);
      db->PaletteStmts.deleteAll = NULL;
   }
   if(db->PaletteStmts.selectByid){
      sqlite3_finalize(db->PaletteStmts.selectByid);
      db->PaletteStmts.selectByid = NULL;
   }
   if(db->PaletteStmts.deleteByid){
      sqlite3_finalize(db->PaletteStmts.deleteByid);
      db->PaletteStmts.deleteByid = NULL;
   }
}
int dbPaletteCreateTable(DB_assets *db){
   static const char *cmd = "CREATE TABLE \"Palette\" (\"id\" STRING PRIMARY KEY UNIQUE ON CONFLICT REPLACE, \"palette\" BLOB);";
   return dbExecute((DBBase*)db, cmd);
}
int dbPaletteInsert(DB_assets *db, const DBPalette *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Palette\" (\"id\", \"palette\") VALUES (:id, :palette);";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->PaletteStmts.insert, 1, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->PaletteStmts.insert, 2, obj->palette, obj->paletteSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbPaletteUpdate(DB_assets *db, const DBPalette *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Palette\" SET (\"palette\" = :palette) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_blob(db->PaletteStmts.update, 1, obj->palette, obj->paletteSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_text(db->PaletteStmts.update, 2, c_str(obj->id), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBPalette) *dbPaletteSelectAll(DB_assets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Palette\";";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBPalette) *out = vecCreate(DBPalette)(&dbPaletteDestroy);

   while((result = sqlite3_step(db->PaletteStmts.selectAll)) == SQLITE_ROW){
      DBPalette newObj = {0};

      newObj.id = stringCreate(sqlite3_column_text(db->PaletteStmts.selectAll, 0));
      newObj.paletteSize = sqlite3_column_bytes(db->PaletteStmts.selectAll, 1);
      newObj.palette = checkedCalloc(1, newObj.paletteSize);
      memcpy(newObj.palette, sqlite3_column_blob(db->PaletteStmts.selectAll, 1), newObj.paletteSize);
      
      vecPushBack(DBPalette)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBPalette)(out);
      return NULL;
   }

   return out;
}
DBPalette dbPaletteSelectFirstByid(DB_assets *db, const char *id){
   DBPalette out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Palette\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_text(db->PaletteStmts.selectByid, 1, id, -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->PaletteStmts.selectByid)) == SQLITE_ROW){
      out.id = stringCreate(sqlite3_column_text(db->PaletteStmts.selectByid, 0));
      out.paletteSize = sqlite3_column_bytes(db->PaletteStmts.selectByid, 1);
      out.palette = checkedCalloc(1, out.paletteSize);
      memcpy(out.palette, sqlite3_column_blob(db->PaletteStmts.selectByid, 1), out.paletteSize);
   };

   return out;
}
void dbPaletteDeleteAll(DB_assets *db){

}
void dbPaletteDeleteByid(DB_assets *db, const char *id){

}
